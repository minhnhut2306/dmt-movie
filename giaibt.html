<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Giải tự luận hệ phương trình – Gauss từng bước (JS)</title>
<style>
  :root{--bg:#0b0f1a;--card:#11192d;--ink:#eaf1ff;--mut:#9fb0cf;--line:#26355e;--acc:#5aa0ff}
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#0b0f1a,#0a0e18);color:var(--ink);font:14px/1.5 Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:18px 14px;text-align:center}
  h1{font-size:20px;margin:0 0 6px}
  .wrap{max-width:1100px;margin:0 auto;padding:14px;display:grid;grid-template-columns:320px 1fr;gap:14px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:16px;box-shadow:0 10px 28px rgba(0,0,0,.25)}
  .pad{padding:14px}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
  label{font-size:12px;color:var(--mut);display:block;margin-bottom:6px}
  input[type=number],textarea,button,select{font:inherit}
  input[type=number],select{width:100%;padding:9px 10px;background:#0f162b;border:1px solid #213158;border-radius:12px;color:var(--ink)}
  button{padding:9px 12px;border-radius:12px;border:1px solid #27437d;background:linear-gradient(180deg,#173a79,#122a54);color:#d9e8ff;cursor:pointer}
  button:hover{filter:brightness(1.05)}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid var(--line);padding:6px 8px;text-align:center}
  .aug{border-left:3px double var(--acc)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:13px}
  .scroll{max-height:60vh;overflow:auto;border-radius:12px}
  .steps{white-space:pre;tab-size:4}
  .hint{color:var(--mut);font-size:12px}
  .pill{display:inline-flex;gap:6px;align-items:center;background:#0d1631;border:1px solid #29407a;border-radius:999px;padding:5px 10px;margin:4px 6px 0 0}
</style>
</head>
<body>
<header>
  <h1>Giải tự luận hệ tuyến tính – Khử Gauss từng bước (hiển thị phép biến đổi hàng)</h1>
  <div class="hint"><b>Tóm tắt:</b> Nhập ma trận mở rộng <code>[A \| b]</code> → bấm <b>Giải tự luận</b> để xem toàn bộ phép biến đổi hàng (đổi/nhân/cộng trừ), RREF và nghiệm. Có thể chọn chế độ <b>Không chuẩn hoá pivot</b> để hạn chế phân số sớm.</div>
</header>
<div class="wrap">
    <div class="card pad" style="grid-column:1/-1">
      <h3 style="margin-top:0">Hướng dẫn chi tiết (từng bước)</h3>
      <ol>
        <li><b>Chọn kích thước hệ:</b> Điền <b>m</b> = số phương trình (số hàng), <b>n</b> = số ẩn (số cột của A).</li>
        <li><b>Tạo bảng nhập:</b> Bấm <b>Tạo bảng</b>. Một bảng hiện ra có <b>n</b> cột hệ số và 1 cột cuối là <b>b</b>.</li>
        <li><b>Nhập ma trận mở rộng [A | b]:</b> Mỗi hàng là 1 phương trình. Ví dụ Hệ (1):
          <div class="mono" style="margin:.4rem 0 .2rem">R1: 1  1  2  ||  1<br/>R2: -3 -2  4  ||  4<br/>R3: -2  1  6  ||  5</div>
          <span class="hint">(Có nút <b>Điền ví dụ (Hệ 1)</b> để điền sẵn.)</span>
        </li>
        <li><b>Giải tự luận:</b>
          <ul>
            <li><b>Giải tự luận (Gauss chuẩn hoá pivot)</b>: luôn chia để pivot = 1 ngay khi chọn trụ → bước giải rõ ràng, dễ đọc.</li>
            <li><b>Giải (không chuẩn hoá pivot)</b>: dùng tổ hợp tuyến tính trước, chuẩn hoá ở cuối → hạn chế phân số sớm.</li>
          </ul>
        </li>
        <li><b>Đọc lời giải:</b> Khối <b>Nhật ký từng bước</b> in <u>mọi phép biến đổi hàng</u> kèm ma trận sau mỗi phép. Cuối cùng có <b>RREF</b> và <b>Nghiệm</b>.</li>
        <li><b>Lưu lời giải:</b> Bấm <b>Xuất .txt</b> để tải toàn bộ log tự luận về máy.</li>
      </ol>
      <div class="hint">Mẹo: Nếu thấy xuất hiện nhiều phân số, thử lại với nút <b>Giải (không chuẩn hoá pivot)</b>. Khi nhập số thập phân, công cụ sẽ tự quy đổi sang phân số để tính chính xác.</div>
    </div>
  <div class="card pad">
    <h3 style="margin-top:0">1) Cấu hình & Nhập</h3>
    <div class="grid">
      <div>
        <label>Số phương trình (m)</label>
        <input type="number" id="m" value="3" min="1" max="10"/>
      </div>
      <div>
        <label>Số ẩn (n)</label>
        <input type="number" id="n" value="3" min="1" max="10"/>
      </div>
    </div>
    <div style="margin:10px 0" class="hint">Sau khi bấm <b>Tạo bảng</b>, điền hệ số A và vế phải b.</div>
    <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
      <button id="build">Tạo bảng</button>
      <button id="prefill1">Điền ví dụ (Hệ 1 trong ảnh)</button>
      <button id="clear">Xoá dữ liệu</button>
    </div>
    <div id="gridArea" style="margin-top:10px"></div>
  </div>

  <div class="card pad">
    <h3 style="margin-top:0">2) Giải & Nhật ký từng bước</h3>
    <div class="row" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px">
      <button id="solve">Giải tự luận (Gauss chuẩn hoá pivot = 1)</button>
      <button id="solveNoScale" title="Không chuẩn hoá pivot, chỉ dùng cộng-trừ để bớt phân số">Giải (không chuẩn hoá pivot)</button>
      <button id="exportTxt">Xuất .txt</button>
    </div>
    <div id="meta"></div>
    <div class="scroll mono steps" id="steps"></div>
  </div>
</div>

<script>
// ---------- Fraction (BigInt) ----------
function gcd(a,b){a=a<0n?-a:a;b=b<0n?-b:b;while(b){[a,b]=[b,a%b]}return a||1n}
class Fr{constructor(n,d=1n){if(d===0n) throw Error('Denominator 0'); if(d<0n){n=-n; d=-d;} const g=gcd(n,d); this.n=n/g; this.d=d/g;}
  static from(x){ if (x instanceof Fr) return x; if (typeof x==='bigint') return new Fr(x,1n); if (Number.isInteger(x)) return new Fr(BigInt(x),1n); // string/number with decimal
    const s = String(x).trim(); if (/^-?\d+$/.test(s)) return new Fr(BigInt(s),1n);
    if (/^-?\d*\.\d+$/.test(s)) { const neg=s.startsWith('-'); const [a,b]=s.replace('-','').split('.'); const p=BigInt(10n ** BigInt(b.length)); const n=BigInt(a||'0')*p + BigInt(b); return new Fr(neg?-n:n, p); }
    throw Error('Không phân tích được số: '+x);
  }
  add(o){o=Fr.from(o); return new Fr(this.n*o.d + o.n*this.d, this.d*o.d)}
  sub(o){o=Fr.from(o); return new Fr(this.n*o.d - o.n*this.d, this.d*o.d)}
  mul(o){o=Fr.from(o); return new Fr(this.n*o.n, this.d*o.d)}
  div(o){o=Fr.from(o); return new Fr(this.n*o.d, this.d*o.n)}
  neg(){return new Fr(-this.n,this.d)}
  isZero(){return this.n===0n}
  eq(o){o=Fr.from(o); return this.n===o.n && this.d===o.d}
  valueOf(){ return Number(this.n)/Number(this.d) }
  toString(){ if(this.d===1n) return String(this.n); if(this.n===0n) return '0'; return `${this.n}/${this.d}`; }
}

// ---------- Matrix helpers ----------
function buildInputs(m,n){
  const area=document.getElementById('gridArea');
  const tbl=document.createElement('table');
  const thead=document.createElement('thead');
  const hr=document.createElement('tr');
  for(let j=0;j<n;j++){ const th=document.createElement('th'); th.textContent='a'+(j+1); hr.appendChild(th); }
  const thb=document.createElement('th'); thb.textContent='b'; thb.className='aug'; hr.appendChild(thb); thead.appendChild(hr); tbl.appendChild(thead);
  const tb=document.createElement('tbody');
  for(let i=0;i<m;i++){
    const tr=document.createElement('tr');
    for(let j=0;j<n+1;j++){
      const td=document.createElement('td'); if(j===n) td.className='aug';
      const inp=document.createElement('input'); inp.type='number'; inp.step='any'; inp.placeholder='0'; inp.className='mono'; inp.style.width='100%';
      td.appendChild(inp); tr.appendChild(td);
    }
    tb.appendChild(tr);
  }
  tbl.appendChild(tb); area.innerHTML=''; area.appendChild(tbl);
}

function readAug(){
  const t=document.querySelector('#gridArea table'); if(!t) return null;
  const rows=[...t.querySelectorAll('tbody tr')]; if(rows.length===0) return null;
  const n = rows[0].children.length-1; const m=rows.length;
  const M = Array.from({length:m},()=>Array(n+1).fill(new Fr(0n)));
  for(let i=0;i<m;i++){
    const inputs=rows[i].querySelectorAll('input');
    for(let j=0;j<=n;j++){
      const s=inputs[j].value.trim();
      const val=s? Fr.from(s) : new Fr(0n);
      M[i][j]=val;
    }
  }
  return {m,n,M};
}

// pretty print matrix
function matToAscii(M){
  // M: array of array<Fr> for augmented matrix (last col augmented)
  const m=M.length, n=M[0].length-1; // last is b
  const cells = M.map(r=>r.map(x=>x.toString()));
  // set a bar before last column
  const wid=[]; for(let j=0;j<=n;j++){ let w=0; for(let i=0;i<m;i++) w=Math.max(w,cells[i][j].length); wid[j]=w; }
  let s='['+ '-'.repeat(wid.reduce((a,b)=>a+b,0)+3*n+5) +']\n';
  for(let i=0;i<m;i++){
    let line='| ';
    for(let j=0;j<=n;j++){
      const pad=wid[j]-cells[i][j].length; line+= ' '.repeat(pad)+cells[i][j];
      if(j===n-0) { /* aug already last col */ }
      if(j===n-1) line+='  ||  ';// separator before last col
      else if(j<n) line+='  ';
    }
    line+=' |'; s+=line+'\n';
  }
  s+= '['+ '-'.repeat(wid.reduce((a,b)=>a+b,0)+3*n+5) +']';
  return s;
}

// ---------- Gaussian elimination with step log ----------
function gaussSolveVerbose(Min, options={scalePivot:true}){
  const M = Min.map(r=>r.map(x=>new Fr(x.n,x.d))); // deep clone
  const m=M.length, n=M[0].length-1;
  const steps=[];
  const log = (title)=>{ steps.push((title?title+'\n':'')+matToAscii(M)+'\n'); };
  log('Ma trận mở rộng ban đầu [A || b]');

  let row=0, col=0;
  const pivots=[]; // (row,col)
  while(row<m && col<n){
    // tìm hàng có phần tử khác 0 lớn nhất |a_{i,col}|
    let sel=-1; for(let i=row;i<m;i++){ if(!M[i][col].isZero()){ sel=i; break; } }
    if(sel===-1){ col++; continue; }
    if(sel!==row){ [M[sel],M[row]]=[M[row],M[sel]]; log(`Đổi chỗ hàng R${sel+1} ↔ R${row+1}`); }

    // chuẩn hoá pivot về 1 (tuỳ chọn)
    const piv = M[row][col];
    if(options.scalePivot && !(piv.eq(new Fr(1n,1n)))){
      for(let j=col;j<=n;j++) M[row][j]=M[row][j].div(piv);
      log(`Chia hàng R${row+1} cho ${piv.toString()} để được pivot 1`);
    }

    // khử dưới (làm 0 các phần tử dưới pivot)
    for(let i=row+1;i<m;i++){
      const a = options.scalePivot ? M[i][col] : M[i][col];
      if(a.isZero()) continue;
      if(options.scalePivot){ // R_i := R_i - a * R_row
        for(let j=col;j<=n;j++) M[i][j]=M[i][j].sub(a.mul(M[row][j]));
        log(`R${i+1} := R${i+1} - (${a.toString()})·R${row+1}`);
      }else{
        // không chuẩn hoá: dùng tổ hợp tuyến tính để tránh phân số sớm
        // R_i := piv*R_i - a*R_row
        for(let j=col;j<=n;j++) M[i][j]= M[row][col].mul(M[i][j]).sub(a.mul(M[row][j]));
        log(`R${i+1} := (${M[row][col].toString()})·R${i+1} - (${a.toString()})·R${row+1}`);
      }
    }
    pivots.push([row,col]);
    row++; col++;
  }

  // phát hiện vô nghiệm (hàng 0 ... 0 || c≠0)
  for(let i=0;i<m;i++){
    let all0=true; for(let j=0;j<n;j++) if(!M[i][j].isZero()) { all0=false; break; }
    if(all0 && !M[i][n].isZero()){
      log('Phát hiện hàng 0 … 0 || c≠0 ⇒ hệ vô nghiệm.');
      return {type:'none', steps:steps.join('\n'), M};
    }
  }

  // khử ngược để RREF
  for(let k=pivots.length-1;k>=0;k--){
    const [r,c]=pivots[k];
    // nếu chưa chuẩn hoá, chuẩn hoá tại đây
    const pv = M[r][c];
    if(!pv.eq(new Fr(1n,1n))){ for(let j=c;j<=n;j++) M[r][j]=M[r][j].div(pv); log(`Chuẩn hoá pivot cuối: R${r+1} := R${r+1} / ${pv.toString()}`); }
    // làm 0 phía trên
    for(let i=0;i<r;i++){
      const a=M[i][c]; if(a.isZero()) continue;
      for(let j=c;j<=n;j++) M[i][j]=M[i][j].sub(a.mul(M[r][j]));
      log(`R${i+1} := R${i+1} - (${a.toString()})·R${r+1}`);
    }
  }

  // xác định hạng và nghiệm
  const pivotCols=new Set(pivots.map(p=>p[1]));
  const rank = pivotCols.size;
  if(rank<n){
    // vô số nghiệm – biểu diễn tham số
    const free=[]; for(let j=0;j<n;j++) if(!pivotCols.has(j)) free.push(j);
    const expr=Array(n).fill(null);
    free.forEach((j,k)=>expr[j]=`t${k+1}`);
    for(const [r,c] of pivots){
      let s = M[r][n].toString();
      for(let j=0;j<n;j++) if(j!==c && !M[r][j].isZero()){
        const coef = M[r][j].neg();
        const part = expr[j]??`x${j+1}`; s += ` + (${coef.toString()})*(${part})`;
      }
      expr[c]=s;
    }
    return {type:'infinite', steps:steps.join('\n'), M, expr, free, rank};
  } else {
    // nghiệm duy nhất
    const x=Array(n).fill('0');
    for(const [r,c] of pivots){ x[c]=M[r][n].toString(); }
    return {type:'unique', steps:steps.join('\n'), M, x, rank};
  }
}

// ---------- UI ----------
const mEl=document.getElementById('m');
const nEl=document.getElementById('n');
function rebuild(){ buildInputs(+mEl.value,+nEl.value); }

document.getElementById('build').onclick=rebuild;

document.getElementById('clear').onclick=()=>{ rebuild(); };

document.getElementById('prefill1').onclick=()=>{
  mEl.value=3; nEl.value=3; rebuild();
  const data=[ [1,1,2,1], [-3,-2,4,4], [-2,1,6,5] ];
  const rows=document.querySelectorAll('#gridArea tbody tr');
  rows.forEach((tr,i)=>{ const ins=tr.querySelectorAll('input'); data[i].forEach((v,j)=>ins[j].value=v); });
};

function runSolve(scalePivot){
  const d=readAug(); if(!d){ alert('Hãy tạo bảng và nhập số liệu.'); return; }
  const res = gaussSolveVerbose(d.M, {scalePivot});
  const steps = res.steps + '\n\nDạng RREF sau cùng:\n' + matToAscii(res.M) + '\n';
  let meta='';
  meta += `<span class="pill">m=${d.m}, n=${d.n}</span>`;
  meta += `<span class="pill">rank(A) ≈ ${res.rank ?? '—'}</span>`;
  if(res.type==='unique') meta += `<span class="pill">Nghiệm duy nhất</span>`;
  if(res.type==='infinite') meta += `<span class="pill">Vô số nghiệm (bậc tự do ${res.free.length})</span>`;
  if(res.type==='none') meta += `<span class="pill">Vô nghiệm</span>`;
  document.getElementById('meta').innerHTML=meta;

  let tail='';
  if(res.type==='unique') tail='\nNghiệm: '+res.x.map((v,i)=>`x${i+1}=${v}`).join(', ');
  else if(res.type==='infinite') tail='\nNghiệm tham số:\n'+res.expr.map((e,i)=>`x${i+1} = ${e??'0'}`).join('\n');
  else if(res.type==='none') tail='\nHệ vô nghiệm (tồn tại hàng 0 … 0 || c≠0).';

  document.getElementById('steps').textContent = steps + tail;
}

document.getElementById('solve').onclick=()=>runSolve(true);

document.getElementById('solveNoScale').onclick=()=>runSolve(false);

// export txt
 document.getElementById('exportTxt').onclick=()=>{
   const txt=document.getElementById('steps').textContent||'';
   const blob=new Blob([txt],{type:'text/plain'});
   const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='giai-tu-luan-gauss.txt'; a.click(); URL.revokeObjectURL(a.href);
 };

// init
rebuild();
</script>
</body>
</html>
